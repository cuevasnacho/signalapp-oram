require "tree_path.jinc"

inline
fn bucket_store_clear(
  reg u64 bucket_store,
  #msf reg u64 msf
) -> #msf reg u64
{
  reg u64 i bound data;
  reg bool cond;

  #declassify data = (64u)[bucket_store + 16];
  data = #protect(data, msf);
  bound = ((1 << PATH_LENGTH) - 1) * ENCRYPTED_BUCKET_SIZE;
  i = 0;
  while { cond = i < bound; } (cond) {
    msf = #update_msf(cond, msf);
    (u8)[data + i] = -1;
    i += 1;
  }
  msf = #update_msf(!cond, msf);

  return msf;
}

inline
fn bucket_store_root() -> reg u64
{
  reg u64 r;
  r = #SHL(1, PATH_LENGTH - 1);
  r -= 1;
  return r;
}

fn bucket_store_read_bucket_blocks(
  reg u64 bucket_store,
  reg u64 bucket_id,
  reg u64 bucket_data,
  #msf reg u64 msf
) -> #msf reg u64
{
  reg u64 offset encrypted_bucket data;
  reg u8 t8;
  inline int i;

  #declassify data = (64u)[bucket_store + 16];
  data = #protect(data, msf);
  offset = bucket_id * ENCRYPTED_BUCKET_SIZE;
  encrypted_bucket = data + offset;
  for i = 0 to DECRYPTED_BLOCK_SIZE_QWORDS * BLOCKS_PER_BUCKET * 8
  {
    t8 = (u8)[encrypted_bucket + i];
    (u8)[bucket_data + i] = t8;
  }
  return msf;
}

fn bucket_store_write_bucket_blocks(
  reg u64 bucket_store,
  reg u64 bucket_id,
  reg u64 bucket_data,
  #msf reg u64 msf
) -> #msf reg u64
{
  reg u64 offset encrypted_bucket data;
  reg u8 t8;
  inline int i;

  #declassify data = (64u)[bucket_store + 16];
  data = #protect(data, msf);
  offset = bucket_id * ENCRYPTED_BUCKET_SIZE;
  encrypted_bucket = data + offset;
  for i = 0 to DECRYPTED_BLOCK_SIZE_QWORDS * BLOCKS_PER_BUCKET * 8
  {
    t8 = (u8)[bucket_data + i];
    (u8)[encrypted_bucket + i] = t8;
  }

  return msf;
}
