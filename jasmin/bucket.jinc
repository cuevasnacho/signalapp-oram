require "tree_path.jinc"

inline
fn _bucket_store_data(
  reg u64 bucket_store,
  #msf reg u64 msf
) -> reg u64, #msf reg u64
{
  reg u64 p;
  #declassify p = (64u)[bucket_store + 16];
  p = #protect(p, msf);
  return p, msf;
}

inline
fn bucket_store_clear(
  reg u64 bucket_store,
  #msf reg u64 msf
) -> #msf reg u64
{
  reg u64 i bound data;
  reg bool cond;

  data, msf = _bucket_store_data(bucket_store, msf);
  bound = ((1 << PATH_LENGTH) - 1) * ENCRYPTED_BUCKET_SIZE;
  i = 0;
  while { cond = i < bound; } (cond) {
    msf = #update_msf(cond, msf);
    (u8)[data + i] = -1;
    i += 1;
  }
  msf = #update_msf(!cond, msf);

  return msf;
}

inline
fn bucket_store_root() -> reg u64
{
  reg u64 r;
  r = #SHL(1, PATH_LENGTH - 1);
  r -= 1;
  return r;
}

fn bucket_store_read_bucket_blocks(
  reg u64 bucket_store,
  reg u64 bucket_id,
  reg u64 bucket_data,
  #msf reg u64 msf
) -> #msf reg u64
{
  reg u64 offset encrypted_bucket data r64;
  inline int i;

  data, msf = _bucket_store_data(bucket_store, msf);
  offset = bucket_id * ENCRYPTED_BUCKET_SIZE;
  encrypted_bucket = data + offset;
  for i = 0 to DECRYPTED_BLOCK_SIZE_QWORDS * BLOCKS_PER_BUCKET
  {
    r64 = (64u)[encrypted_bucket + 8 * i];
    (u64)[bucket_data + 8 * i] = r64;
  }
  return msf;
}

fn bucket_store_write_bucket_blocks(
  reg u64 bucket_store,
  reg u64 bucket_id,
  reg u64 bucket_data,
  #msf reg u64 msf
) -> #msf reg u64
{
  reg u64 offset encrypted_bucket data r64;
  inline int i;

  data, msf = _bucket_store_data(bucket_store, msf);
  offset = bucket_id * ENCRYPTED_BUCKET_SIZE;
  encrypted_bucket = data + offset;
  for i = 0 to DECRYPTED_BLOCK_SIZE_QWORDS * BLOCKS_PER_BUCKET
  {
    r64 = (64u)[bucket_data + 8 * i];
    (u64)[encrypted_bucket + 8 * i] = r64;
  }

  return msf;
}
