param int BASE = 1<<32;

export
fn _divmod128by64(
  reg u64 u1 u0 v,
  reg u64 q
)
{
  reg u64 u32_u u21_u u10_u rhat left right;
  reg u64 s;
  reg u64[2] vs;
  reg u64[2] qs;
  reg u64[2] low_us;
  reg u8 c0 c1;
  reg bool b;
  // shift the divisor, v, so that the most significant bit is set
  s = #LZCNT(v);
  v <<= s;

  // We'll work in base 2^32. Split the divisor into the high digit (v1) and low digit (v0)
  vs[1] = v;
  vs[1] >>= 32;
  vs[0] = v;
  vs[0] &= 0xffffffff;

  // Now shift the dividend by the same amount, and split it into its "upper" and "lower" parts (u32 and u10)
  if (s > 0) {
    s = 64 - s;
    u0 >>= s;
    u32_u = u1 << s;
    u32_u |= u0;
    u10_u = u0 << s;
  } else {
    u32_u = u1;
    u10_u = u0;
  }

  // Split the low part of u into 32-bit digits
  low_us[1] = u10_u;
  low_us[1] >>= 32;
  low_us[0] = u10_u;
  low_us[0] &= 0xffffffff;

  // If we think of u = u3*base^3 + u2*base^2 + u1*base + u0
  // (as in Knuth) then u32 = u3*base + u2, u10 = u1*base + u0
  qs[1] = u32_u / vs[1];

  rhat = u32_u % vs[1];

  left = qs[1];
  left *= vs[0];
  right = rhat;
  right <<= 32;
  right += low_us[1];

  while {
    b = qs[1] >= BASE;
    c0 = #SETcc(b);
    b = left > right;
    c1 = #SETcc(b);
    c0 |= c1;

    qs[1] -= 1;
    rhat = #LEA(rhat + vs[1]);
    b = rhat < BASE;
    c1 = #SETcc(b);
    c0 &= c1;
    b = c0 != 0;
  } (b) {
    left -= vs[0];
    right = (rhat << 32);
    right |= low_us[1];
  }

  // Second iteration of Knuth's "outer loop".  REcall we can think of u = u3*base^3 + u2*base^2 + u1*base + u0
  // In the first iteration we set u <- u - qs[1]*v. After this change, u21 = u2*base + u1.
  u21_u = qs[1] * v;
  u32_u <<= 32;
  u21_u = low_us[1] - u21_u;
  u21_u = #LEA(u21_u + u32_u);

  qs[0] = u21_u / vs[1];
  rhat = u21_u % vs[1];

  left = qs[0] * vs[0];
  right = (rhat << 32); 
  right |= low_us[0];

  while {
    // (qs[0] >= base) || (left > right)
    b = qs[0] >= BASE;
    c0 = #SETcc(b);
    b = left > right;
    c1 = #SETcc(b);
    c0 |= c1;

    qs[0] -= 1;
    rhat = #LEA(rhat + vs[0]);
    b = rhat < BASE;
    c1 = #SETcc(b);
    c0 &= c1;
    b = c0 != 0;
  } (b) {
    left -= vs[0];
    right = (rhat << 32);
    right |= low_us[0];
  }

  qs[1] <<= 32;
  qs[0] |= qs[1];
  [q] = qs[0];
}
