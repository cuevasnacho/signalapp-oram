require "consts.jinc"
require "util.jinc"
require "bucket.jinc"

inline
fn _stash_extend_overflow(
  reg u64 stash,
  inline int length
)
{
  reg u64 old_num_blocks new_num_blocks;
  reg u64 addr old_len new_len flags new_addr prot fd offset err tmp;
  reg u64 blocks bucket_assignments;
  stack u64 blocks_s;
  inline int i;

  old_num_blocks = [stash + 8 * NUM_BLOCKS_ADDR];
  new_num_blocks = #LEA(old_num_blocks + STASH_GROWTH_INCREMENT);

  // (re)allocate new space, free the old
  blocks = [stash];
  old_len = old_num_blocks * DECRYPTED_BLOCK_SIZE;
  () = #spill(old_num_blocks);
  new_len = new_num_blocks * DECRYPTED_BLOCK_SIZE;
  flags = 1;
  new_addr = 0;
  blocks = blocks;
  new_addr = #mremap(blocks, old_len, new_len, flags, new_addr);
  [stash] = new_addr;
  blocks_s = new_addr;

  // free bucket_assignments
  bucket_assignments = [stash + 8 * BUCKET_ASSIGNMENTS_ADDR];
  () = #unspill(old_num_blocks);
  old_len = old_num_blocks * 8;
  err = #munmap(bucket_assignments, old_len);

  // mmap memory for bucket_assignments
  addr = 0;
  new_len = new_num_blocks * 8;
  prot = 0x1 | 0x2;   // PROT_READ | PROT_WRITE
  flags = 0x2 | 0x20; // MAP_PRIVATE | MAP_ANONYMOUS
  fd = -1;
  offset = 0;
  new_addr = #mmap(addr, new_len, prot, flags, fd, offset);
  [stash + 8 * BUCKET_ASSIGNMENTS_ADDR] = new_addr;

  // update our alias pointers
  blocks = blocks_s;
  tmp = #LEA(blocks + length * BLOCKS_PER_BUCKET * DECRYPTED_BLOCK_SIZE);
  [stash + 8 * PATH_BLOCKS_ADDR] = blocks;
  [stash + 8 * OVERFLOW_BLOCKS_ADDR] = tmp;

  // initialize new memory
  () = #unspill(old_num_blocks);
  old_num_blocks *= DECRYPTED_BLOCK_SIZE;
  blocks = #LEA(blocks + old_num_blocks);
  for i = 0 to DECRYPTED_BLOCK_SIZE_QWORDS * STASH_GROWTH_INCREMENT
  {
    [blocks + 8 * i] = -1;
  }

  // update counts
  [stash + 8 * NUM_BLOCKS_ADDR] = new_num_blocks;
  [stash + 8 * OVERFLOW_CAPACITY_ADDR] += STASH_GROWTH_INCREMENT;
}

// returns the index of the last nonempty blocks in overflow
fn _stash_overflow_ub(
  reg u64 stash,
  #msf reg u64 msf
) -> reg u64, #msf reg u64
{
  reg u64 i j overflow_blocks bid offset;
  reg u64 zero;
  reg bool b cond;

  i, msf = stash_overflow_capacity(stash, msf);
  overflow_blocks, msf = stash_overflow_blocks(stash, msf);
  offset = i;
  offset *= 8 * DECRYPTED_BLOCK_SIZE_QWORDS;
  overflow_blocks += offset;
  zero = #set0();
  while { cond = i > 0; } (cond) {
    msf = #update_msf(cond, msf);
    overflow_blocks -= 8 * DECRYPTED_BLOCK_SIZE_QWORDS; // (i - 1)
    #declassify bid = (64u)[overflow_blocks]; //! if bid is secret we cannot use it in condition
    bid = #protect(bid, msf);
    b = bid != EMPTY_BLOCK_ID;
    j = zero;
    j = #CMOVcc(b, i, j);
    i -= 1;
    b = bid != EMPTY_BLOCK_ID;
    i = #CMOVcc(b, zero, i);
  }
  msf = #update_msf(!cond, msf);
  return j, msf;
}

inline
fn _first_block_in_bucket_for_level(
  reg u64 stash,
  reg u64 level,
  #msf reg u64 msf
) -> reg u64, #msf reg u64
{
  reg u64 p offset;
  p, msf = stash_path_blocks(stash, msf);
  offset = level * BLOCKS_PER_BUCKET;
  offset *= DECRYPTED_BLOCK_SIZE_QWORDS * 8;
  p = #LEA(p + offset);
  return p, msf;
}

inline
fn _cond_copy_block(
  reg u8 cond,
  reg u64 dst src
)
{
  inline int i;
  for i = 0 to DECRYPTED_BLOCK_SIZE_QWORDS {
    _cond_obv_cpy_u64(cond, dst, src);
    dst = #LEA(dst + 8);
    src = #LEA(src + 8);
  }
}

inline
fn _i_cond_copy_block(
  reg u8 cond,
  reg u64 dst,
  reg ptr u64[DECRYPTED_BLOCK_SIZE_QWORDS] src
) -> reg ptr u64[DECRYPTED_BLOCK_SIZE_QWORDS]
{
  reg u64 tmp va;
  inline int i;
  for i = 0 to DECRYPTED_BLOCK_SIZE_QWORDS {
    va = (64u)[dst];
    tmp = _ternary(cond, src[u64 i], va);
    (u64)[dst] = tmp;
    dst = #LEA(dst + 8);
  }
  return src;
}

inline
fn _cond_swap_blocks(
  reg u8 cond,
  reg u64 a b
)
{
  inline int i;
  for i = 0 to DECRYPTED_BLOCK_SIZE_QWORDS {
    _cond_obv_swap_u64(cond, a, b);
    a = #LEA(a + 8);
    b = #LEA(b + 8);
  }
}

inline
fn _i_cond_swap_blocks(
  reg u8 cond,
  reg ptr u64[DECRYPTED_BLOCK_SIZE_QWORDS] a,
  reg u64 b
) -> reg ptr u64[DECRYPTED_BLOCK_SIZE_QWORDS]
{
  reg u64 tmp rb;
  inline int i;
  for i = 0 to DECRYPTED_BLOCK_SIZE_QWORDS {
    rb = (64u)[b];
    tmp = _ternary(cond, a[u64 i], rb);
    (u64)[b] = tmp;
    a[u64 i] = _ternary(cond, rb, a[u64 i]);
    b = #LEA(b + 8);
  }
  return a;
}

// Precondition: `target` is an empty block OR no block in the bucket has ID equal to `target_block_id`
// Postcondition: No block in the bucket has ID equal to `target_block_id`, `target` is either empty or `target->id == target_block_id`.
fn stash_add_path_bucket(
  reg u64 stash bucket_store,
  reg u64 bucket_id target_block_id,
  reg u64 target,
  #msf reg u64 msf
) -> #msf reg u64
{
  reg u64 lvl bucket_blocks bid;
  reg u8 c;
  reg bool cond;
  inline int i;

  lvl = tree_path_level(bucket_id);
  bucket_blocks, msf = _first_block_in_bucket_for_level(stash, lvl, msf);
  msf = bucket_store_read_bucket_blocks(bucket_store, bucket_id, bucket_blocks, msf);
  for i = 0 to BLOCKS_PER_BUCKET
  {
    bid = (64u)[bucket_blocks];
    cond = bid == target_block_id;
    c = #SETcc(cond);
    _cond_swap_blocks(c, target, bucket_blocks);
    bucket_blocks += 8 * DECRYPTED_BLOCK_SIZE_QWORDS;
  }
  return msf;
}

fn _i_stash_add_path_bucket(
  reg u64 stash bucket_store,
  reg u64 bucket_id target_block_id,
  reg ptr u64[DECRYPTED_BLOCK_SIZE_QWORDS] target,
  #msf reg u64 msf
) -> reg ptr u64[DECRYPTED_BLOCK_SIZE_QWORDS], #msf reg u64
{
  reg u64 lvl bucket_blocks bid;
  reg u8 c;
  reg bool cond;
  inline int i;

  lvl = tree_path_level(bucket_id);
  bucket_blocks, msf = _first_block_in_bucket_for_level(stash, lvl, msf);
  #update_after_call msf = bucket_store_read_bucket_blocks(bucket_store, bucket_id, bucket_blocks, msf);
  bucket_blocks = #protect(bucket_blocks, msf);
  target = #protect_ptr(target, msf);
  for i = 0 to BLOCKS_PER_BUCKET
  {
    bid = (64u)[bucket_blocks];
    cond = bid == target_block_id;
    c = #SETcc(cond);
    target = _i_cond_swap_blocks(c, target, bucket_blocks);
    bucket_blocks += 8 * DECRYPTED_BLOCK_SIZE_QWORDS;
  }
  return target, msf;
}

// Precondition: `target` is an empty block OR no block in the overflow has ID equal to `target_block_id`
// Postcondition: No block in the overflow has ID equal to `target_block_id`, `target` is either empty or `target->id == target_block_id`.
fn stash_scan_overflow_for_target(
  reg u64 stash,
  reg u64 target_block_id,
  reg u64 target,
  #msf reg u64 msf
) -> #msf reg u64
{
  reg u64 ub i bid overflow_blocks;
  reg u8 c;
  reg bool cond;

  ub, msf = _stash_overflow_ub(stash, msf);
  overflow_blocks, msf = stash_overflow_blocks(stash, msf);
  i = 0;
  while (i < ub)
  {
    bid = (64u)[overflow_blocks];
    cond = bid == target_block_id;
    c = #SETcc(cond);
    _cond_swap_blocks(c, target, overflow_blocks);
    overflow_blocks += 8 * DECRYPTED_BLOCK_SIZE_QWORDS;
    i += 1;
  }

  return msf;
}

fn _i_stash_scan_overflow_for_target(
  reg u64 stash,
  reg u64 target_block_id,
  reg ptr u64[DECRYPTED_BLOCK_SIZE_QWORDS] target,
  #msf reg u64 msf
) -> reg ptr u64[DECRYPTED_BLOCK_SIZE_QWORDS], #msf reg u64
{
  reg u64 ub i bid overflow_blocks;
  reg u8 c;
  reg bool b cond;

  #update_after_call ub, msf = _stash_overflow_ub(stash, msf);
  stash = #protect(stash, msf);
  target = #protect_ptr(target, msf);
  overflow_blocks, msf = stash_overflow_blocks(stash, msf);
  i = 0;
  while { cond = i < ub; } (cond) {
    msf = #update_msf(cond, msf);
    bid = (64u)[overflow_blocks];
    b = bid == target_block_id;
    c = #SETcc(b);
    target = _i_cond_swap_blocks(c, target, overflow_blocks);
    overflow_blocks += 8 * DECRYPTED_BLOCK_SIZE_QWORDS;
    i += 1;
  }
  msf = #update_msf(!cond, msf);
  return target, msf;
}

// Precondition: there is no block with ID `new_block->id` anywhere in the stash - neither the path_Stash nor the overflow.
inline
fn stash_add_block(
  reg u64 stash new_block,
  #msf reg u64 msf,
  inline int length
) -> #msf reg u64
{
  reg u64 bid overflow_capacity overflow_blocks i;
  reg u8 c1 c2;
  reg bool b;

  overflow_blocks, msf = stash_overflow_blocks(stash, msf);
  overflow_capacity, msf = stash_overflow_capacity(stash, msf);

  c1 = 0; // inserted
  while {
    i = 0;
    while (i < overflow_capacity)
    {
      bid = [overflow_blocks];
      // cond
      c1 = !c1;
      b = bid == EMPTY_BLOCK_ID;
      c2 = #SETcc(b);
      c2 &= c1;
      _cond_copy_block(c2, overflow_blocks, new_block);
      c1 = !c1;
      c1 |= c2;
      i += 1;
      overflow_blocks = #LEA(overflow_blocks + 8 * DECRYPTED_BLOCK_SIZE_QWORDS);
    }
  } (c1 == 0) {
    _stash_extend_overflow(stash, length);
  }
  return msf;
}

inline
fn _i_stash_add_block(
  reg u64 stash,
  reg ptr u64[DECRYPTED_BLOCK_SIZE_QWORDS] new_block,
  #msf reg u64 msf,
  inline int length
) -> reg ptr u64[DECRYPTED_BLOCK_SIZE_QWORDS], #msf reg u64
{
  reg u64 bid overflow_capacity overflow_blocks i;
  reg u8 c1 c2;
  reg bool b cond;

  overflow_blocks, msf = stash_overflow_blocks(stash, msf);
  overflow_capacity, msf = stash_overflow_capacity(stash, msf);

  // c1 = 0; // inserted
  // while {
  //   i = 0;
  //   while { cond = i < overflow_capacity; } (cond) {
  //     msf = #update_msf(cond, msf);
  //     bid = [overflow_blocks];
  //     // cond
  //     c1 = !c1;
  //     b = bid == EMPTY_BLOCK_ID;
  //     c2 = #SETcc(b);
  //     c2 &= c1;
  //     new_block = _i_cond_copy_block(c2, overflow_blocks, new_block);
  //     c1 = !c1;
  //     c1 |= c2;
  //     i += 1;
  //     overflow_blocks = #LEA(overflow_blocks + 8 * DECRYPTED_BLOCK_SIZE_QWORDS);
  //   }
  //   msf = #update_msf(!cond, msf);
  //   cond = c1 == 0;
  // } (cond) { // !inserted
  //   msf = #update_msf(cond, msf);
  //   () = #spill(new_block, overflow_blocks, overflow_capacity, c1);
  //   _stash_extend_overflow(stash, length);
  //   msf = #init_msf();
  //   () = #unspill(new_block, overflow_blocks, overflow_capacity, c1);
  // }
  // msf = #update_msf(!cond, msf);
  c1 = 0; // inserted
  i = 0;
  while { cond = i < overflow_capacity; } (cond) {
    msf = #update_msf(cond, msf);
    bid = [overflow_blocks];
    // cond
    c1 = !c1;
    b = bid == EMPTY_BLOCK_ID;
    c2 = #SETcc(b);
    c2 &= c1;
    new_block = _i_cond_copy_block(c2, overflow_blocks, new_block);
    c1 = !c1;
    c1 |= c2;
    i += 1;
    overflow_blocks = #LEA(overflow_blocks + 8 * DECRYPTED_BLOCK_SIZE_QWORDS);
  }
  msf = #update_msf(!cond, msf);
  return new_block, msf;
}

inline
fn _stash_assign_block_to_bucket_path(
  #spill_to_mmx reg u64 stash path,
  inline int index,
  #msf reg u64 msf
) -> #msf reg u64
{
  // spill_to_mmx variables
  #spill_to_mmx reg u64 bucket_assignments;
  // pointer variables
  reg u64 path_blocks bucket_occupancy;
  // temporary variables
  reg u64 r1 r2 bucket_id tree_bound tmp;
  // spill_to_mmx
  #spill_to_mmx reg u64 bid bpos;
  // boolean variables
  reg u8 c1 c2 c3;
  reg bool b;
  inline int max_level lvl offset;
  
  // the block cannot be assigned to this level or higher
  max_level = (index / BLOCKS_PER_BUCKET) + 1;

  path_blocks, msf = stash_path_blocks(stash, msf);
  offset = index * 8 * DECRYPTED_BLOCK_SIZE_QWORDS;
  bid = (64u)[path_blocks + offset];
  bid = #protect(bid, msf);
  () = #spill(bid);
  bpos = (64u)[path_blocks + offset + 8];
  bpos = #protect(bpos, msf);
  () = #spill(bpos);

  bucket_occupancy, msf = stash_bucket_occupancy(stash, msf);
  bucket_assignments, msf = stash_bucket_assignments(stash, msf);
  () = #spill(path, stash, bucket_assignments);

  c1 = #set0_8(); // is_assigned
  for lvl = 0 to max_level {
    r2 = (64u)[bucket_occupancy + 8 * lvl];
    r2 = #protect(r2, msf);
    () = #unspill(path);
    bucket_id = (64u)[path + 8 + 8 * lvl];
    bucket_id = #protect(bucket_id, msf);

    c1 = !c1;
    // is_valid
    tree_bound = tree_path_lower_bound(bucket_id);
    () = #unspill(bpos);
    b = tree_bound <= bpos;
    c2 = #SETcc(b);
    c2 &= c1;
    tree_bound = tree_path_upper_bound(bucket_id);
    () = #unspill(bpos);
    b = tree_bound >= bpos;
    c3 = #SETcc(b);
    c2 &= c3;
    // bucket_has_room
    b = r2 < BLOCKS_PER_BUCKET;
    c3 = #SETcc(b);
    c2 &= c3;
    // not is_empty
    () = #unspill(bid);
    b = bid != EMPTY_BLOCK_ID;
    c3 = #SETcc(b);
    c2 &= c3;
    // is_assigned = cond | is_assigned;
    c1 = !c1;
    c1 |= c2;
    b = c2 != 0;
    
    // If `b` is true, put it in the bucket: increment the bucket occupancy and set the bucket assignment
    // for this position.
    // increment this, it will only get saved if `b` is true.
    r1 = #LEA(r2 + 1);
    r1 = #CMOVcc(b, r1, r2);
    () = #unspill(bucket_assignments);
    (u64)[bucket_occupancy + 8 * lvl] = r1;
    r1 = (64u)[bucket_assignments + 8 * index];
    r1 = #protect(r1, msf);
    b = c2 != 0;
    tmp = (64u)lvl;
    r1 = #CMOVcc(b, tmp, r1);
    (u64)[bucket_assignments + 8 * index] = r1;
  }

  return msf;
}

inline
fn _stash_assign_block_to_bucket_overflow(
  #spill_to_mmx reg u64 stash path,
  reg u64 index,
  #msf reg u64 msf,
  inline int length
) -> #msf reg u64
{
  // spill_to_mmx variables
  #spill_to_mmx reg u64 assignment_index bucket_assignments;
  // pointer variables
  reg u64 path_blocks bucket_occupancy;
  // temporary variables
  reg u64 r1 r2 bucket_id tree_bound tmp;
  // spill_to_mmx
  #spill_to_mmx reg u64 bid bpos;
  // boolean variables
  reg u8 c1 c2 c3;
  reg bool b cond;
  inline int lvl max_level;
  
  // the block cannot be assigned to this level or higher
  max_level = (64u)length;
  assignment_index = #LEA(BLOCKS_PER_BUCKET * length + index);

  path_blocks, msf = stash_path_blocks(stash, msf);
  tmp = assignment_index;
  tmp *= 8 * DECRYPTED_BLOCK_SIZE_QWORDS;
  bid = (64u)[path_blocks + tmp];
  bid = #protect(bid, msf);
  () = #spill(bid);
  bpos = (64u)[path_blocks + tmp + 8];
  bpos = #protect(bpos, msf);
  () = #spill(bpos);

  bucket_occupancy, msf = stash_bucket_occupancy(stash, msf);
  bucket_assignments, msf = stash_bucket_assignments(stash, msf);
  () = #spill(path, stash, assignment_index, bucket_assignments);

  c1 = #set0_8(); // is_assigned
  for lvl = 0 to max_level {
    r2 = (64u)[bucket_occupancy + 8 * lvl];
    r2 = #protect(r2, msf);
    () = #unspill(path);
    bucket_id = (64u)[path + 8 + 8 * lvl];
    bucket_id = #protect(bucket_id, msf);

    c1 = !c1;
    // is_valid
    tree_bound = tree_path_lower_bound(bucket_id);
    () = #unspill(bpos);
    b = tree_bound <= bpos;
    c2 = #SETcc(b);
    c2 &= c1;
    tree_bound = tree_path_upper_bound(bucket_id);
    () = #unspill(bpos);
    b = tree_bound >= bpos;
    c3 = #SETcc(b);
    c2 &= c3;
    // bucket_has_room
    b = r2 < BLOCKS_PER_BUCKET;
    c3 = #SETcc(b);
    c2 &= c3;
    // not is_empty
    () = #unspill(bid);
    b = bid != EMPTY_BLOCK_ID;
    c3 = #SETcc(b);
    c2 &= c3;
    // is_assigned = cond | is_assigned;
    c1 = !c1;
    c1 |= c2;
    b = c2 != 0;
    
    // If `b` is true, put it in the bucket: increment the bucket occupancy and set the bucket assignment
    // for this position.
    // increment this, it will only get saved if `b` is true.
    r1 = #LEA(r2 + 1);
    r1 = #CMOVcc(b, r1, r2);
    () = #unspill(assignment_index, bucket_assignments);
    (u64)[bucket_occupancy + 8 * lvl] = r1;
    r1 = (64u)[bucket_assignments + 8 * assignment_index];
    r1 = #protect(r1, msf);
    b = c2 != 0;
    tmp = lvl;
    r1 = #CMOVcc(b, tmp, r1);
    (u64)[bucket_assignments + 8 * assignment_index] = r1;
  }

  return msf;
}

inline
fn _stash_place_empty_blocks(
  reg u64 stash,
  #msf reg u64 msf,
  inline int length
) -> #msf reg u64
{
  // standard variables
  reg u64 curr_bucket num_blocks;
  // pointer variables
  reg u64 blocks bucket_occupancy bucket_assignments;
  // temporary variables
  reg u64 tmp_bo bid i tmp_r offset;
  // boolean variables
  reg u8 c1 c2;
  reg bool b cond;
  inline int j;

  blocks, msf = stash_blocks(stash, msf);
  bucket_occupancy, msf = stash_bucket_occupancy(stash, msf);
  bucket_assignments, msf = stash_bucket_assignments(stash, msf);
  num_blocks, msf = stash_num_blocks(stash, msf);
  curr_bucket = #set0();
  i = 0;
  while { cond = i < num_blocks; } (cond) {
    msf = #update_msf(cond, msf);
    c1 = 0; // found_curr_bucket
    for j = 0 to length
    {
      c1 = !c1;
      // bucket_has_room
      #declassify tmp_bo = (64u)[bucket_occupancy + 8 * j];
      tmp_bo = #protect(tmp_bo, msf);
      b = tmp_bo != BLOCKS_PER_BUCKET;
      c2 = #SETcc(b);
      c2 &= c1;
      // set_curr_bucket
      b = c2 != 0;
      tmp_r = (64u)j;
      curr_bucket = #CMOVcc(b, tmp_r, curr_bucket);
      c1 = !c1;
      c1 |= c2;
    }
    tmp_bo = (64u)[bucket_occupancy + 8 * curr_bucket];
    offset = 8 * DECRYPTED_BLOCK_SIZE_QWORDS * i;
    bid = (64u)[blocks + offset];
    // cond_place_in_bucket
    b = bid == EMPTY_BLOCK_ID;
    c2 = #SETcc(b);
    b = tmp_bo < BLOCKS_PER_BUCKET;
    c1 = #SETcc(b);
    c1 &= c2;
    b = c1 != 0;

    tmp_r = #LEA(tmp_bo + 1);
    tmp_r = #CMOVcc(b, tmp_r, tmp_bo);
    (u64)[bucket_occupancy + 8 * curr_bucket] = tmp_r;
    tmp_bo = (64u)[bucket_assignments + 8 * i];
    tmp_r = #CMOVcc(b, curr_bucket, tmp_bo);
    (u64)[bucket_assignments + 8 * i] = tmp_r;
    i += 1;
  }
  msf = #update_msf(!cond, msf);
  // at the end, every bucket should be full
  return msf;
}

inline
fn _stash_assign_buckets(
  reg u64 stash path,
  #msf reg u64 msf,
  inline int length
) -> #msf reg u64
{
  // standard variables
  reg u64 ub num_blocks;
  // pointer variables
  reg u64 bucket_assignments bucket_occupancy;
  // temporary variables
  reg u64 it;
  #mmx reg u64 path_s;
  reg bool cond;
  inline int i lvl;

  // assign all blocks to "overflow" - level UINT64_MAX and set all occupancy to 0
  bucket_assignments, msf = stash_bucket_assignments(stash, msf);
  num_blocks, msf = stash_num_blocks(stash, msf);

  it = 0;
  while {cond = it < num_blocks; } (cond) {
    msf = #update_msf(cond, msf);
    (u64)[bucket_assignments + 8 * it] = (64u)-1; it += 1;
  }
  msf = #update_msf(!cond, msf);
  bucket_occupancy, msf = stash_bucket_occupancy(stash, msf);
  for i = 0 to length { (u64)[bucket_occupancy + 8 * i] = (64u)0; }

  // assign blocks in path to buckets first
  for lvl = 0 to length
  { for i = 0 to BLOCKS_PER_BUCKET
    {
      msf = _stash_assign_block_to_bucket_path(stash, path, lvl * BLOCKS_PER_BUCKET + i, msf);
    }
  }

  // () = #spill(path);
  path_s = path;
  // assign blocks in overflow to buckets
  #update_after_call ub, msf = _stash_overflow_ub(stash, msf);
  stash = stash;
  stash = #protect(stash, msf);
  path = path_s;
  it = 0;
  while { cond = it < ub; } (cond) {
    msf = #update_msf(cond, msf);
    msf = _stash_assign_block_to_bucket_overflow(stash, path, it, msf, length);
    it = #LEA(it + 1);
  }
  msf = #update_msf(!cond, msf);

  // now assign empty blocks to fill the buckets
  msf = _stash_place_empty_blocks(stash, msf, length);

  return msf;
}

inline
fn _comp_blocks(
  reg u64 blocks block_level_assignments,
  reg u64 idx1 idx2
) -> reg u8
{
  reg u64 bla1 bla2 b1 b2 offset;
  reg u8 r s;
  reg bool b;

  bla1 = (64u)[block_level_assignments + 8 * idx1];
  bla2 = (64u)[block_level_assignments + 8 * idx2];
  offset = 8 * idx1;
  offset *= DECRYPTED_BLOCK_SIZE_QWORDS;
  offset += 8;
  b1 = (64u)[blocks + offset];
  offset = 8 * idx2;
  offset *= DECRYPTED_BLOCK_SIZE_QWORDS;
  offset += 8;
  b2 = (64u)[blocks + offset];

  b = b1 > b2;
  r = #SETcc(b);
  b = bla1 == bla2;
  s = #SETcc(b);
  r &= s;
  b = bla1 > bla2;
  s = #SETcc(b);
  r |= s;
  return r;
}

inline
fn _min(reg u64 a b) -> reg u64
{
  // b ^ ((a ^ b) & -((a - b) >> 63));
  reg u64 sub;
  sub = a;
  sub -= b;
  sub >>= 63;
  sub = -sub;
  a = a;
  a ^= b;
  a &= sub;
  b ^= a;
  return b;
}

inline
fn _odd_even_msort(
  #public reg u64 blocks block_level_assignments,
  reg u64 lb ub,
  #msf reg u64 msf
) -> #msf reg u64
{
  reg u64 n;
  n = ub - lb;
  // if (n <= 1) return;

  reg u64 current_assignment i remaining step next_step;
  reg u64 rsi_0 mask adjusted_range rax r13 rdi block_offset rdx rcx rax_3 pairs_to_process r8 r11 r10 rbx rsi left right rcx_1 rax_4 r9_1 rdi_1 r13_1;
  reg u32 edi;
  reg u8 dil al dl;
  reg bool b cond;
  inline int r;

  #mmx reg u64 msf_s;

  current_assignment = #LEA(block_level_assignments + lb * 8);
  i = lb;
  remaining = n;
  step = 1;
  () = #spill(current_assignment);

  while {
    next_step = #LEA(step + step);
    rsi_0 = #LEA(step - 1);
    cond = step != 0;
    if (cond) {
      msf = #update_msf(cond, msf);
      while {
        mask = rsi_0;
        mask &= step;
        adjusted_range = remaining;
        adjusted_range -= step;
        cond = mask < adjusted_range;
        if (cond) {
          msf = #update_msf(cond, msf);
          rax = step * 2720;
          () = #spill(remaining);
          r13 = adjusted_range;
          rdi = #LEA(step + step);
          () = #spill(rsi_0);
          r13 -= mask;
          () = #spill(blocks, rax);
          block_offset = #LEA(i + mask);
          block_offset *= 1360;
          () = #spill(block_level_assignments, i, adjusted_range);
          rdx = #LEA(block_offset + blocks);
          block_offset = #LEA(step + i);
          block_offset = #LEA(block_level_assignments + block_offset * 8);
          rcx = rdx;
          () = #spill(block_offset);
          rax_3 = step * 1360;
          () = #spill(rax_3);

          while {
            pairs_to_process = r13;
            b = step < r13;
            pairs_to_process = step if b;
            cond = pairs_to_process != 0;
            if (cond) {
              msf = #update_msf(cond, msf);
              () = #spill(rdi);
              () = #unspill(current_assignment);
              current_assignment = #protect(current_assignment, msf);
              pairs_to_process += mask;
              r8 = rcx;
              r11 = #LEA(mask * 8);
              () = #spill(rcx);
              r10 = mask;
              rbx = #LEA(current_assignment + r11);
              () = #spill(r13, current_assignment);
              () = #unspill(block_offset);
              block_offset = #protect(block_offset, msf);
              
              r11 += block_offset;
              () = #spill(block_offset);
              () = #unspill(rax_3);
              rax_3 = #protect(rax_3, msf);
              rsi = #LEA(rax_3 + rcx);
              () = #spill(rax_3);

              while { cond = r10 != pairs_to_process; } (cond) {
                msf = #update_msf(cond, msf);
                left = r10;
                left /= next_step;
                left = left;
                right = #LEA(r10 + step);
                () = #spill(r10);
                right /= next_step;
                right = right;
                () = #spill(next_step);
                cond = left == right;
                if (cond) {
                  msf = #update_msf(cond, msf);
                  rdx = [rbx];
                  rcx_1 = [r11];
                  rax_4 = [r8 + 8];

                  b = [rsi + 8] < rax_4;
                  dil = #SETcc(b);
                  b = rdx == rcx_1;
                  al = #SETcc(b);
                  al &= dil;
                  b = rdx > rcx_1;
                  dl = #SETcc(b);
                  al |= dl;

                  edi = (32u)al;
                  r9_1 = (64u)edi;
                  r9_1 -= 1;
                  rdi_1 = (64u)edi;
                  rdi_1 = -rdi_1;

                  for r = 0 to 170 {
                    rdx = [r8 + r * 8];
                    rcx_1 = [rsi + r * 8];
                    r13_1 = rdx;
                    rcx_1 &= rdi_1;
                    rdx &= rdi_1;
                    r13_1 &= r9_1;
                    rcx_1 |= r13_1;
                    [r8 + r * 8] = rcx_1;
                    rcx_1 = [rsi + r * 8];
                    rcx_1 &= r9_1;
                    rdx |= rcx_1;
                    [rsi + r * 8] = rdx;
                  }

                  rax_4 = [rbx];
                  rdx = [r11];
                  rcx_1 = rax_4;
                  rdx &= rdi_1;
                  rax_4 &= rdi_1;
                  rcx_1 &= r9_1;
                  rdx |= rcx_1;
                  [rbx] = rdx;
                  r9_1 &= [r11];
                  rax_4 |= r9_1;
                  [r11] = rax_4;
                } else {
                  msf = #update_msf(!cond, msf);
                }
                () = #unspill(r10, next_step);
                r10 = #protect(r10, msf);
                next_step = #protect(next_step, msf);
                r10 = #LEA(r10 + 1);
                rbx = #LEA(rbx + 8);
                r11 = #LEA(r11 + 8);
                rsi = #LEA(rsi + 1360);
                r8 = #LEA(r8 + 1360);
              }
              msf = #update_msf(!cond, msf);
              () = #unspill(rdi, r13, rcx);
              rdi = #protect(rdi, msf);
              r13 = #protect(r13, msf);
              rcx = #protect(rcx, msf);
            } else {
              msf = #update_msf(!cond, msf);
            }
            () = #unspill(rax);
            rax = #protect(rax, msf);
            mask = #LEA(mask + rdi);
            r13 -= rdi;
            rcx = #LEA(rcx + rax);
            () = #spill(rax);
            () = #unspill(adjusted_range);
            adjusted_range = #protect(adjusted_range, msf);
            cond = mask < adjusted_range;
            () = #spill(adjusted_range);
          } (cond) {
            msf = #update_msf(cond, msf);
          }
          msf = #update_msf(!cond, msf);
          () = #unspill(remaining, rsi_0, blocks, block_level_assignments, i);
          remaining = #protect(remaining, msf);
          rsi_0 = #protect(rsi_0, msf);
          blocks = #protect(blocks, msf);
          // block_level_assignments = #protect(block_level_assignments, msf);
          i = #protect(i, msf);
        } else {
          msf = #update_msf(!cond, msf);
        }
        step >>= 1;
        cond = step != 0;
      } (cond) {
        msf = #update_msf(cond, msf);
      }
      msf = #update_msf(!cond, msf);
    } else {
      msf = #update_msf(!cond, msf);
    }
    step = next_step;
    cond = next_step < remaining;
  } (cond) {
    msf = #update_msf(cond, msf);
  }
  msf = #update_msf(!cond, msf);

  return msf;
}

inline
fn stash_build_path(
  reg u64 stash path,
  #msf reg u64 msf,
  inline int length
) -> #msf reg u64
{
  reg u64 overflow_size;
  reg u64 blocks bucket_assignments;

  msf = _stash_assign_buckets(stash, path, msf, length);

  #update_after_call overflow_size, msf = _stash_overflow_ub(stash, msf);
  stash = stash;
  stash = #protect(stash, msf);
  overflow_size = #LEA(overflow_size + length * BLOCKS_PER_BUCKET);
  
  blocks, msf = stash_blocks(stash, msf);
  bucket_assignments, msf = stash_bucket_assignments(stash, msf);
  
  msf = _odd_even_msort(blocks, bucket_assignments, 0, overflow_size, msf);

  return msf;
}

inline
fn stash_clear(
  reg u64 stash,
  #msf reg u64 msf
) -> #msf reg u64
{
  reg u64 blocks num_blocks i;
  reg bool cond;

  blocks, msf = stash_blocks(stash, msf);
  num_blocks, msf = stash_num_blocks(stash, msf);
  num_blocks *= DECRYPTED_BLOCK_SIZE_QWORDS;
  i = 0;
  while { cond = i < num_blocks; } (cond) {
    msf = #update_msf(cond, msf);
    (u64)[blocks + 8 * i] = -1;
    i += 1;
  }
  msf = #update_msf(!cond, msf);

  return msf;
}